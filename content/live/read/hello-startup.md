# 《奔跑吧, 程序员》

2020-08-08


并不是一本很深刻需要细细品味的书。但这本书基本涵盖了目前小规模的互联网创业方方面面。其中有一些思维方式不只在创业过程中，而且在生活中都可以供我们细细品味。就是那种给你一个线索，让你顺藤摸瓜自己慢慢探索的书。我只把有冲击的点罗列下来，并未进行仔细整理。其实贯穿全书，作者提示我们创业最重要的不只是要以客户为中心，同时我们还要时时刻刻去思辨我的行动的原因与目的与理想。

<!-- more -->
<img style="height:300px;" src="https://img2.doubanio.com/view/subject/l/public/s29816092.jpg" />


## 创业点子

- 当今世上最有价值的创业都是组合多学科各种知识的结果。
- Novich 列出了公司失败的几个原因，其中之一“医生想要更多的病人，而不是更有效率的诊所。”其中的差别听上去似乎很微妙，因为高效的诊所就会有更多的病人，但是关注错误的问题会导致整个公司误入歧途
- 帮人省钱和帮人赚钱是等价的在经济学实践中属于基本。但是创业就不一定了


## 产品设计

- 从根本上说，设计就是如何去呈现信息，让他人可以理解并使用这些信息。
- 设计的目的是把一些东西传递给用户。
- 设计不是按钮、彩色图表或功能特性，它关乎人和目标。在上面的故事中，人就是软件专家，不幸的是，问题跟踪软件无法帮助我们实现跟踪项目工作情况的目标。更糟糕的是，它的失败出现在设计最为重要的目标上。
- 沟通是设计目的之所在。我们努力把信息呈现给用户，告诉他们可以做什么，向他们展示如何去做。
- 不要再为“平均的人”设计产品。人平均下来就是不洋不土、不男不女，如果你为平均的每个人做设计，那么谁都不会喜欢你设计出的东西。
- 简单其实就是一件我必须完成的事。我的产品必须完成的一件事是什么？我的设计必须向用户传达的一件事是什么？定期问问自己这几个问题，得到答案后亦可再次发问。我所设计的产品是否做了这样一件事？抑或我迷失在了细节的实现当中，产品最终做的是其他的事情。
- 要找出更优雅的设计，需要对问题形成更深入的理解。
- 而检验是否成功让用户的生活变简单的唯一方法，就是在用户使用你的产品时观察他们，这个过程的正式名称叫作可用性测试。

- 衬线和粗细的变化令每个字母看上去都更明显，有助于提高阅读速度，特别是有大量文本的时候。因此，衬线字型比较适合字数比较多的正文文本和打印材料（大多数图书正文使用的都是衬线字型）。衬线字型作为最古老的字型，不仅可以追溯到使用印刷术的年代，甚至可以一路追溯到古罗马人刻在石头上的字母。所以，如果想要有“传统的”感觉，就可以在标题中使用衬线字型。
- 所有字型都可以分成五类：衬线字型、无衬线字型、装饰性字型、手写型和等宽字型
- Sans 是一个法语单词，意思是“没有”，所以 Sans serif 字型就是没有衬线的字型。
- 但是无衬线字型通常在非常大或非常小的字号上有更好的表现，比如大标题或者小的帮助文本。事实上，如果字母太小，或者在低分辨率的屏幕上查看，衬线字型的微小细节看起来会变得模糊，所以无衬线字型在数字媒介上非常流
- 强调。这些字型是独特、有趣且丰富多样的。如果想让一些文本与众不同，用这样的字型就再好不过了，如图 3-21 所示。但是，这样的字型其实并不方便阅读，所以通常会把它限制在标题或子标题的少数单词中
- 手写型看起来就像用手写的潦草字体或书法字型，如图 3-22 所示。和装饰性字型一样，使用这种字型也可以很好地起到强调作用，但只用在不多的几个单词或字母上就行了，因为手写型也是不容易阅读的。
- 等宽字型的每一个字母都会占据同样的空间，所以通常只会在显示代码段（这就是为什么所有的终端、文本编辑器和 IDE 都会使用等宽字型）时，或者想让文本看起来像是从打字机打出来时使用
- 事实上，没有图书、杂志或报纸会使用下划线，因为这么做会让文本更难阅读。唯一的例外就是网站，下划线可以用来表示超链接。所以我们不应该在其他地方使用下划线

- 大多数时候，（用户）实际上（如果我们运气好的话）在每个新页面上只会瞥一眼，扫视一下文本，点一下令他们感兴趣或差不多像他们正在寻找的东西的第一个链接。页面上往往有一大片区域对用户来说是看不到的。我们想的是“伟大的文学作品”（至少也是“产品宣传册”），而用户的实际感受更像是“百公里时速一闪而过的广告牌”。
- 第一个窍门就是先用黑白图进行设计，然后再添加颜色
- 第二个技巧就是使用专业人士提供的调色板，

- 左上：文案；右上：布局（对齐和亲密性）；左下：排版（行宽、行距、字型、字体）；右下：对比与色彩。
- 最简可行产品（minimum viable product），或者叫 MVP。
- 我们可以把MVP 的实现归纳为以下几点：(1) 找出风险最大、最重要的设想；(2) 把这种设想以一种可测试的假设描述出来；(3) 构建一个最小的实验（一个MVP）去测试你的假设；(4) 分析结果；(5) 用新发现去重复第一个
- 早期传教士，他们有问题或需要。他们明白自己遇到了问题。他们正在积极地寻找解决方案，
- 并且设定了找到方案的时间表。问题让他们非常痛苦，所以他们已经拼凑出了临时的解决办法。他们已经承诺购买，或者可以在短时间内获得或申请到预算去购买

### 数据与营销

- 但是有几种类型的指标是所有公司都需要跟踪的：获取（acquisition）；激活（activation）；留存（retention）；推荐（referral）；收益（revenue）；神奇数字（the magic number）。

### 技术栈的选择

- 如果使用关系型数据库遇到了障碍，极有可能是因为我们的数据量和可用性方面的需求已经超出了单台服务器的能力范围。此时，我们要优先考虑找出可以扩展的最简单的解决方案。按照复杂程度，以下列出了最常见的一些选择：对数据存储格式和现有数据库的查询进行优化；在数据库之前设置缓存（例如内存缓存）；建立主- 从复制；对无关联的表进行垂直分区；对单张表进行水平分区；建立多主
- 评估编程语言时所要考虑的关键取舍。编程范式它是面向对象的，还是函数式编程语言？它是否支持静态类型或者自动内存管理？适用问题例如，C 对于嵌入式系统是特别合适的，Erlang 适合容错的分布式系统，而R 则适合统计。性能该语言对并发的处理能力如何？该语言是否使用了垃圾收集？如何对收集器进行调整？生产效率该语言的流行程度如何？针对该语言的框架和库的数量有多少？它的简洁程度
- 一个用 JavaScript 和 Node.js 实现的前端框架，通过非阻塞的 JSON-over-HTTP 调用从后台获取数据；一个用 Python 和 Flask 实现的 RESTful 后台服务，将产品和用户数据存放在 PostgreSQL 中；一个用 Java、DropWizard、Lucene和 Redis 实现的 RESTful 后台服务，负责管理搜索索引；一个 HBase 集群用于离线分析。
- 单一职责原则（single responsibility principle，SRP）规定了每一个类、函数和变量都应该只有一个单一的目的。
- 整洁的代码应该遵循依赖反转原则：高级的模块不应该依赖于低级的模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象
- 我们也应该把这些库作为依赖项去注入吗？根据经验，我们更应该对一些有如下特征的库的具体实现进行注入抽象。具有副作用。在不同的环境中有不同的表现

### 可扩展性

我们在编写实现代码之前就编写测试代码，便可以从这种反馈中获得最大的好处，这就是所谓的**测试驱动开发（Test Driven Development，TDD）**。

- 判断测试质量的一个方法就是计算自动化测试运行的时候，有百分之多少的生产代码被执行了。这一衡量尺度称为**代码覆盖度**
- **单元测试**验证的是单独的一小个代码单元的功能。单元（unit）并没有明确的定义，但通常都是一个单独的函数，最多也就是一个类
- **集成测试**涵盖的范围非常广泛，从测试若干个类或模块的交互，到测试整个子系统如何一起工作（比如验证后端服务器是否可以正确使用真正的数据库）。和单元测试不同，集成测试允许产生副作用，并对外部环境存在依赖
- **验收测试**则是从客户的角度验证产品的行为，回答“代码是否正确解决问题”的问题。如果创业公司编写出的能完美通过所有单元测试和集成测试的正确代码，实际上却不是客户想要的，这其实就是最大的浪费。
- **性能测试**的目标是验证系统在面对繁重的负载和故障时的稳定性和响应能力。性能测试涵盖了从单元测试到端对端测试的全部范围
- **测试替身**用来在测试中代替真正的依赖项。有几种类型，包括伪造、桩和模拟
- **缺陷密度**（每千行代码的 bug 数量）会随着项目规模的增加而显著增长，所以如果项目的代码行数是两倍，bug 的数量通常就不止两倍
- **信息隐藏**意味着抽象应该比其背后的细节更加简单，就像脑海中的图像要比真正的水果更加简单。
- **结对编程**是一种开发技术，让两名程序员在一台计算机前面工作。一人是驾驶员，负责编写代码；另一人是观察员，负责评审代码，并在更高层次上思考程序。这两名程序员定期交换角色
- 因为根据编程语言的不同，某些类型的信息是不能够由代码来表达的，比如背景信息（例如“这个函数基于某篇论文使用了算法X……”）、对输入的假设（例如“初始参数必须是非负整数”这样的前提条件）、所提供输出的保证（例如“返回值必须永不为空”这样的后置条件）、对任何副作用的解释（例如“该函数会将上传数据存放在临时文件中”）以及对一些无法改进的难看或不直观代码的解释（例如“这是应对bug XXX 的变通做法，直到下一个发布版本才能够修复”）

### 软件交付

- 版本控制系统（version control system，VCS）可以让你对一组文件的变化进行持续跟踪。
- 无论你选择的是哪一种 VCS，都应该遵循两个最佳实践：编写良好的提交信息、及早提交并经常提交。
- 理想状态就是每一次提交都是完全实现了某一个单一目的、大小合理的单元
- 单一目的意味着我们不应该在同一次提交中修复两个 bug 或者实现两个功能，或者在一次提交中重构现有代码和实现新的代码。完全实现意味着我们不应该提交会给构建过程带来问题的代码，或者让用户看到未完成功能的代码。大小合理的单元意味着我们应该把工作分解成较小的、增量式的步骤。
- 花太长时间。我们还可以遵循金丝雀部署模型，实现更安全的部署和回滚。当你部署新版代码时，先部署在单台服务器上，这就叫金丝雀

### 创业文化
- Apple。其他公司也在尝试分布式组织。2013 年，Zappos 宣布他们采用了一种名为 Holocracy 的实践，这种实践去除了许多传统的层级结构、经理和头衔。Holocracy 也被其他几家公司采用，包括 Medium 和 David Allen 公司
- 提供金钱的激励反而会影响表现。这是因为解决蜡烛问题需要创造性，你必须克服功能固着，意识到这个盒子不仅是用来存放大头钉的，而且是可以解决难题的道具。
- 是否仍然有办法可以给她奖金而又不会扼杀她的积极性呢？是的。关键就是要避免使用有条件奖励——根据“如果 - 那么”这样的条件去奖励
  - 比如“如果你做了 X，我就给你 Y”。你把任何奖励挂在人们面前，就是吊杆上的萝卜，自然就成了一种外部激励。员工会以奖励为交换去做工作，这样你就会看到前面讨论的失去动力的各种副作用。
  - 然而，如果奖励是意料之外的，这些副作用中的大部分就会消失 3。和允诺给予奖励不同，你要营造一种环境，让 Anna 关注任务本身并受内在的激励因素驱动（例如公司的使命和她对学习 iOS 以及移动开发技能的渴望）。如果她做得很好，你可以给她一个意想不到的认可，而不是给她一种预期的报酬。
- 开发人员的理想办公室需要满足4 个条件：
  - (1) 一个可以和他人一起工作的地方；
  - (2) 一个可以独处专注工作的地方；
  - (3) 一个可以放下工作的地方；
  - (4) 一种可以根据个人需要定制办公室的
- 在从事大型项目开发时，复杂性分为两种：内在复杂性和偶发复杂性。
  - 内在复杂性是我们尝试解决的问题本身就自带的。举个例子，如果你在开发金融交易算法，找出能够战胜市场的算法就是该问题本身复杂性的一部分——没有办法绕开它。
  - 偶发复杂性则是该问题偶然引起的，或者在解决问题时所采用的某种特定方法的副作用所导致的。如果我们使用C++ 去实现金融交易算法，那么内存泄漏和段错误就是一种偶发复杂性，源于使用该语言不得不进行手动的内存管理——我们可以选择具有自动化内存管理技术的其他语言（比如Java）来避免这种

### 学习
- 但是你学习的目标并不是成为世界上最出色的程序员，而是要成为比昨天更出色的程序员。

### 工具

- 我们可以用 Google的 AdWords Keyword Planner 研究每个月有多少人搜索某些特定术语
- 如要想了解某个特定的竞争者正在做什么，你可以试试用网站分析工具（例如 comScore、Quantcast）和移动分析工具（例如 App Annie、Xyo）去估算他们的流量。你也可以使用 CruchBase 或 AngelList 这样的网站，看看竞争者获得了多少投资以及背后有哪些投资者
-- 有像 Google Fonts 这样的免费网站，也有像 Adobe Typekit 这样的付费网站，
- 如果搜索“字体搭配”，可以找到几十个可以提供提前验证过的精美推荐字体组合的网站，例如 Google Web Fonts Typographic Project（Google 网页字体排版项目）展示了 Google 字体的数十种可行的组合方式，Just My Type 关注的是 Adobe Typekit 字体的组合，而 Fonts in Use 则有一些实际运用的精美排版，并可以根据行业、格式和字型进行筛选。
- 例如，Adobe Color CC 和 Paletton 能够利用颜色理论为你提供配色方案（单色系、邻近色、颜色三角）。Adobe Color CC、COLOURlovers 和 Dribbble 提供的颜色搜索功能还可以对预设的一些颜色方案进行浏览