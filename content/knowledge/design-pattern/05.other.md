---
title: 其他模式
index: Thought.Design Pattern.Practice
---



## 复合模式 Compound Pattern

模式通常会在一起使用, 并被组合在同一个设计方案中

> 复合模式在一个解决方案中结合两个或多个模式,以解决**一般或重复发生**的问题. 普通的模式的组合使用不能成为复合模式

<ToggleContent title="MVC">

- 模型 `Model`: 模型所持所有的数据, 状态和程序逻辑. 模型没有注意到视图和控制器, 虽然它提供了操纵和检索状态的接口,并发送状态改变通知给观察者
  - 模型使用观察者模式,以便观察者更新,同时保持两者之间解耦.
  - 可以用适配器将新的模型适配到原来的视图和控制器上
- 视图 `View`: 用来呈现模型. 视图通常直接从模型中取得它需要显示的状态与数据
  - 视图使用组合模式实现用户界面,用户界面通常组合了嵌套的组件,像面板,框架和按钮
- 控制器 `Controller`: 取得用户的输入并解读其对模型的意思. 
  - 是视图和模型的沟通桥梁, **不包含应用逻辑**
  - 控制器并不是彻底的中介者, 视图持有访问模型状态的**模型引用**, 并没有通过控制器获取模型状态. 
  - 控制器是视图的策略,视图可以使用不同的控制器实现,得到不同的行为


</ToggleContent>


---

## 反模式

> 采用不好的方案解决一个问题


### 黄金榔头

- 问题: 你需要为你的开发选择技术, 而且你正好有一种技术能够主宰这个架构
- 情境: 你需要开发某个新的系统或者一套软件, 然而此系统或软件却无法和开发团队缩熟悉的技术相吻合.
- 吸引力: 
  - 开发者致力于使用他们所熟悉的技术
  - 开发团队并不熟悉其他技术
  - 采用不熟悉的技术被认为风险比较高
  - 使用熟悉的技术做开发,比较容易规划和预估

- 原本的解决方案: 反正就使用熟悉的技术好了.将熟悉的技术强迫性地用在许多问题上, 甚至在明显不适当的地方也照用
- 重构的解决方案: 开发人员通过教育, 培训和读书会,可以学会新的解决方案
- 例子: 当采用开放源码的代替品时, Web公司依然持续使用并维护他们内部自行开发的缓存系统


### 基本类型偏执 primitive obsession

> 在复杂类型更为合适的场景下使用基本类型。