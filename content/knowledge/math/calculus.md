---
title: 微积分
---



## 积分

积分：就是用来计算不规则体的面积体积的一种方法



计算面积：
- 正方形：`width**2`
- 长方形：`width * height`
- 三角形: `width * height / 2`
- 平行四边形: `(upWidth + downWidth) * height / 2`
- 圆形: `radius * radius * Math.PI`
- 椭圆形: `shortRaduis * longRaduis * Math.PI`


计算体积
- 三角锥, 四棱锥: `bottomSquare * height / 3`

### 如何求PI值

用极限方法求PI，夹逼定理

> 将图形看做小长方形的组合
圆内部方格数对应的圆周率 < 圆实际的圆周率< 包含圆边界的方格数对应的圆周率

用长方形的竖条划分圆形

``` ts
      ||||||||
    ||||||||||||
  ||||||||||||||||
||||||||||||||||||||
||||||||||||||||||||
||||||||||||||||||||
  ||||||||||||||||
    ||||||||||||
      ||||||||
Δx1     ...       Δxn
```

`Δ (Delta)` 多用作 **差 difference** 符号。代表非常小的数值

`∫ (integral)` 积分符号 代表和 **和 sum**

`Δx` 趋向于0时变成了 `dx`

`d` - 有精确值的含义，类似 Math.PI. 当宽度趋向于0 计算极限值时使用
`Δ` - 有近似值的含义 类似 3.1415926. 当存在宽度（宽度>0）时使用

椭圆形的面积可以看做圆形在某一对相反的方向拉伸。使这个方向的半径从 r 拉伸到 b。从而是每一个积分的小方块的宽度都拉伸到了 b/r 倍

>  “截面面积总是相等的两个立体图形，其体积也相等” - 卡瓦列利原理(意大利)

整理后的扑克牌与随意放置的扑克牌体积相同

三角锥的体积就是四棱锥应用**卡瓦列利原理**得到的

积分的关键是找到有效分割图形的方法



圆环体是圆环是和圆周的笛卡尔积

> 旋转体的体积 = 旋转的平面图形面积 * 旋转面重心所经过的距离 - 帕普斯-古尔丁定理


圆环体积 

= `小圆的面积 * 小圆圆心经过的距离`

= `(π * r**2) * (2 * π * R)`

= `2 * π**2 * r * R`

圆环表面积 

= `小圆的周长 * 小圆圆心经过的距离`

= `(2 * π * r) * (2 * π * R)`  

= `4 * π**2 * r * R`

说到底，积分可以说就是求取“分割部分之和”，并无其他特别内容。一旦可以写出积分的式子，那么数值计算就很简单了将各种各样的量用积分的式子表达出来，这才是我们需要掌握的必要能力。

## 微分

用另一个维度去观察

微分的含义：
- `Δy/Δx` -> `dy/dx` 当 x 的变化趋近于0时。y的变化量
- 代表点p切线的斜率


准确区分可以忽略的部分与不能忽略的部分。
微分的要领忽略较小部分，取近似值。

微分方程代表变化率，而某一个值代表变化量

``` ts
// 正方形
y = x ** 2 
// 微分
y = 2 * x // 2代表有两条增长边

// 正方体
y = x ** 3
y = 3 * x ** 2 // 3代表有三个增长面
```

> 思考是否超过三维的东西不具备实际意义。你的时间如何流逝；你的钱如何被通胀稀释


> 乘积的微分公式 - 牛顿

``` html
(f * g)' 
= f' * g + f * g'
= df/dx * g + f * dg/dx

e.g.

(x**4)' 
= (x**3 * x)'
= (3 * x**2 * x) + (x**3 * 1)
= 3 * x**3 + x**3
= 4 * x**3

(x**4)'
= (x**2 * x**2)'
= (2 * x * x**2) + (*2 * x * x**2)
= 4 * x**3
```

> 幂函数微分公式 (x**α)' = α * x**(α-1) 


连续的斜率值可以确定曲线的形状. 例如：
 
- `-n` -> `0` -> `-n` 下降阶段台阶
- `n` -> `0` -> `n` 上升阶段台阶
- `-n` -> `0` -> `n` 波谷
- `n` -> `0` -> `-n` 波峰

通过微分方程可以得到函数的性质。
有时候你会先得到函数的性质（微分方程）再推导函数的形式。



单调性表示例

<div class="inline-flex min-w-1/3">

|x   |... |-1  |... |0   |... |1   |... |
|:---|:---|:---|:---|:---|:---|:---|:---|
|f'(x)|+  |0   |+   |0     |- |0      |+|
|f(x) |↗  |-7  |↗   |0(local maximum)|↘|-23(local minimum)|↗|

</div><div></div>

寻找最大值(global maximum)和最小值(global minimum)是微分的一种常见应用。但在过程中经常被局部最大值(local maximum)和局部最小值(global minimum)迷惑。此时一种常见的方法是引入动量。

> 微分方程y为0时解的集合就是原函数局部最大/最小值的集合


拐点：曲线和切线的上下位置关系发生转变的点。

拐点就是“改变弯曲方向的点”

对切线的斜率再次微分会得到“切线斜率的变化率”对应的函数 `f"(x)`

计算器计算三角函数的值时，使用低阶函数近似的方法。


e.g: 圆锥体在斜边 l 不变的情况下。底圆半径r和圆锥高度h为多少时体积最大 p130

``` ts
l = 10

// 勾股定理
h = sqrt(l**2 - r**2)

// 低圆面积
bottomArea = Math.PI * r**2

// 圆柱体公式
volume = bottomArea * h / 3

// 所以得到方程
y = π * r**2 * sqrt(100 - r**2) / 3

// 两边平方后，最大值的坐标点不会变。但去除了根号更方便计算
y**2 = π**2 * r**4 * (100 - r**2) / 9

// π**2/9 为常数也不影响最大值坐标点，所以也可以省略
y**2 = r**4 * (100 - r**2)

// 求下面方程的最大值也就是求微分后方程的解的集合
f = r**4 * (100 - r**2)

// 相加后的微分等于微分后的相加
`f' = 400 * r**3 - 6 * r**5`
`400 * r**3 - 6 * r**5 = 0`
`400 = 6 * r**2`
`400 = 6 * r**2`
`r = sqrt(400/6)` // 8.16496580927726
`h = sqrt(l**2 - r**2) = sqrt(100 - 400/6)` // 5.773502691896257
```


微积分的真相是，重视或舍弃较小的部分，都不是随性而为，而是为了能够推动问题“数学式”前进，所以才这样做。重视某个部分，是因为能够为它能为后面的计算提供便利。是否忽略较小的部分，判断的标准是“该部分是否能够为解题带来积极成果”。微积分，就是这种“结果主义”


## 微积分的可能性

微分和积分互为逆运算

- “圆的面积”的微分就是“圆的周长”: 
  - 当半径增加 `Δr`, 圆的面积增加 `ΔS = Δx * (2 * π * r)`
  - 当 `Δr` 趋近与0时，`ΔS`则趋近于圆的周长。即 `ds/dr = 2 * π * r`
  - `f = π * r**2` -> `f' = 2 * π * r`
- “球的体积”的微分就是“球的表面积” 
  - 当半径增加 `Δr`, 球的体积增加`球的表面积 * Δr` 即：`ΔV = 4 * π * r**2 * Δr`
  当 `Δr` 趋近与0时，`ΔV`则趋近于球的表面积。即 `dV/dr = 4 * π * r**2`
  - `f = 4/3 * π * r**3` -> `f' = 4 * π * r**2`


我们可以认为“圆面积的微分”最终就是(在使`Δr`趋向于0的极限情况下)把圆分割成薄圆环状。


对半径进行微分。一般化地。我们是如何得到面积是与半径有关联的


``` bash
 >>>> d/dx >>>>
 |            |
x**a          ax**(a-1)
 |            |
 <<<<  ∫   <<<<
```

- `x** 2` 的积分是 `(x** 3)/3`
- `x** β` 的积分是 `x** (β+1)/(β+1) + C`

> 幂函数的(不定)积分公式： `∫(x**β) dx = x**(β+1)/(β+1) + C`

通过积分求出原函数叫做不定积分。通常积分符号中不写从哪里到哪里的积分`∫f(x)dx = F(x) + C`
通过积分求面积/体积(具体值)叫做定积分。此时没有常量C `∫[b, a]f(x)dx = F(b) + C - F(a) - C = F(b) - F(a)`

> 幂函数的定积分公式：`∫[b, a](x**β)dx = b**(β+1)/(β+1) - a**(β+1)/(β+1)`

e.g. `y = x**2` 从 1 到 2 的面积

``` js
∫[2, 1]x**2 
= 2**3/3 - 1**3/3 
= 8/3 - 1/3 
= 7/3
```


自然常数e: 函数1/x 从 1 到 e 的积分面积为 1

上面的幂函数积分公式当 `β = -1` 即 `1/x` 时无法进行积分. 此时需要换个思路。

1. 当积分面积为1时，积分下限为1, 求积分上限x: 即 `∫[1,x]x**βdx = 1`

  ``` js
  // 从幂函数的定积分公式得(设：b = 1，a = x, y = 1)：
  ∫[1,x]x**βdx = x**(β+1)/(β+1) - 1**(β+1)/(β+1) = 1

  x**(β+1)/(β+1) = 1 + 1/(β+1)
  x**(β+1) = (β+1) + 1
  x = ((β+1) + 1)**(1/(β+1))

  // 令 β+1 = t
  x = (t + 1)**-t
  // 当 β 趋近 -1 则 t趋近与0
  x = lim(t,0)(t + 1)**-t

  // t = 1,   x = 2.0
  // t = 0.1  x = 2.593742
  // ...
  // t = 0.0001 x = 2.718146
  ```

  得到结果。当积分面积为1时，且积分下限为1, 得到积分上限 `x = 2.718281828....` 此时我我们将x的值称为自然常数`e`.
  即函数`1/x` 从 1 到 e 的积分面积为 1.

2. 下面计算一般情况 y 值对应的 x (即 `y !== 1`). 从而推导出 `x = Math.E**y` 和 `y = Math.log(x)`

``` ts
// 从幂函数的定积分公式得(设：b = 1，a = x)：
∫[1,x]x**βdx = x**(β+1)/(β+1) - 1**(β+1)/(β+1) ≈ y
x**(β+1) - 1 ≈ y * (β+1)
x**(β+1) ≈ y * (β+1) + 1
x ≈ (y * (β+1) + 1) ** -(β+1)

// 令 y * (β+1) = t
x ≈ (t + 1) ** -(t/y)
x ≈ (t + 1) ** (y/t)

// 当β趋近-1, β+1趋近0 则t趋近与0
x = lim(t,0)(t + 1)**(y/t) = lim(t,0)((t + 1)**-t)**y
// lim(t,0)((t + 1)**-t) 的值为 e 则 x = Math.E**y
x = e ** y

// 反过来用x表示y 即
y = Math.log(x)

// 所以得到了
∫[1,x]x**βdx = (x**(β+1)-1**(β+1)) / (β+1) -> Math.log(x)


```

> 反比例积分公式 ∫[1,x]x**-1dx = ∫[1,x]1/xdx = log(x)

e.g.

``` ts
∫[1,2]1/xdx = log2 
// 对1/x 函数 x=1, 到 x=2 所围成的面积为 log2
```


03. 推导指数函数的微分公式 

``` ts
// 由 y = 1/x 的积分为 y = log(x) 得出
dy/dx = 1/x
dx/dy = x
// 带入 x = e ** y
d(e**y)/dy = e ** y
```
把y改写成x, 并用符号表示 `(e**x)' = e ** x` 即`y = e ** x` 即使微分也不会发生变化


``` ts 
// 将 (e**x)' = e ** x 中 x 替换为一般 a * x
d(e**(a*x))/dx = e ** (a*x)
// 应用微积分基本定理
∫ae**(a * x)dx = e ** (a*x) + C 
// 两边除以 a
∫e**(a*x)dx = (1/a) * e**(a*x) + (1/a) * C 
// 因为常数可以合并
```

> 指数函数积分公式: ∫e**(a*x)dx = (1/a) * e**(a*x) + C 


可微性: 

大部分的函数实际上是不可微分的。也存在每一部分都无法微分的函数(魏尔斯特拉斯函数)。无法微分就无法使用 `微分 = 0`这个等式来计算局部最值。

此时可能使用概率模型处理问题更为合适。

在和概率现象纠缠不休的函数中，会频繁出现不可微函数。



Ref:

- 简单微积分：学校未教过的超简易入门技巧 (日 神永正博)