---
title: ECMAScript Features
index: Language.JavaScript.Syntax
---


[ECMA finished proposals](https://github.com/tc39/proposals/blob/HEAD/finished-proposals.md)

## ES2025

::accordion{title="Promise.try"}

æ¥å—ä¸€ä¸ªå‡½æ•°ï¼Œä¸å¸¦å‚æ•°è°ƒç”¨å®ƒ. ä»è€Œç”¨å¼‚æ­¥çš„æ–¹å¼æ•è·ä»–å¯èƒ½æŠ›å‡ºçš„é”™è¯¯ 


``` ts
Promise.try(() => {
  // è¿™é‡Œå¯ä»¥æ˜¯åŒæ­¥æˆ–å¼‚æ­¥ä»£ç 
  return someSynchronousOrAsynchronousFunction()
})
.then(result => {
  console.log('æˆåŠŸç»“æœï¼š', result)
})
.catch(error => {
  console.error('æ•è·åˆ°é”™è¯¯ï¼š', error)
})
``` 

è™½ç„¶ä½¿ç”¨ `Promise.resolve.then` ä¹Ÿå¯ä»¥å®ç°ç±»ä¼¼çš„åŠŸèƒ½ã€‚ä½†åŒæ­¥å‡½æ•°ä¼šå› ä¸ºå¼‚æ­¥æ‰§è¡Œçš„ `Promise.resolve()` è€Œè¢«æ¨è¿Ÿåˆ°ä¸‹ä¸ªæ—¶é’Ÿå‘¨æœŸä¸­æ‰§è¡Œ

``` ts
Promise.resolve().then(() => {
  return someSynchronousOrAsynchronousFunction()
})
.catch(error => {
  console.error('æ•è·åˆ°é”™è¯¯ï¼š', error)
})
```




::

::accordion{title="è¿­ä»£å™¨è¾…åŠ©å‡½æ•°"}

ä½¿è¿­ä»£å™¨ä¹Ÿå¯ä»¥ä½¿ç”¨æ•°ç»„æ–¹æ³•, ä½†è¿™äº›æ–¹æ³•éƒ½æ˜¯æƒ°æ€§æ‰§è¡Œçš„

``` ts
function* naturals() {
  let i = 0;
  while (true) {
    yield i;
    i += 1;
  }
}

const result = naturals().map(value => {
    return value * value
  });
result.next(); //  {value: 0, done: false};
result.next(); //  {value: 1, done: false};
result.next(); //  {value: 4, done: false};
```

**ä¸€èˆ¬æ–¹æ³•**

- `.map(mapperFn)`
- `.filter(filtererFn)`
- `.take(limit)`
- `.drop(limit)`
- `.flatMap(mapperFn)`

**å‰¯ä½œç”¨æ–¹æ³•**

:::note
åªå¯ä»¥åœ¨æœ‰é™è¿­ä»£å™¨ä¸Šä½¿ç”¨ï¼Œå¹¶æ¶ˆè€—æ‰è¿­ä»£å™¨
:::

- `.reduce(reducer [, initialValue ])`
- `.toArray()`
- `.forEach(fn)`
- `.some(fn)`
- `.every(fn)`
- `.find(fn)`

**ä»å¯¹è±¡åˆ›å»º**

å½“ä½¿ç”¨è®¾è®¡æ¨¡å¼åˆ›å»ºè‡ªå·±çš„è¿­ä»£å™¨ç±»æ—¶ï¼Œå¯ä»¥å°†å…¶è½¬åŒ–ä¸ºè¯­è¨€åŸç”Ÿæ”¯æŒçš„è¿­ä»£å™¨

``` ts
class Iter {
  next() {
    return { done: false, value: 1 }
  }
}

const iter = new Iter()
const wrapper = Iterator.from(iter)

wrapper.next() // { value: 1, done: false }
```


::

::accordion{title="JSON æ¨¡å—"}

JSå¼•æ“æ”¯æŒå¯¼å…¥ JSON æ–‡ä»¶

::

::accordion{title="å¯¼å…¥è¯­æ³•å¢å¼º"}

``` ts
import json from "./foo.json" with { type: "json" }

import("foo.json", { with: { type: "json" } })
```


::

::accordion{title="æ­£åˆ™è¡¨è¾¾å¼å¯é‡å¤ç»„å"}

``` ts
let str1 = '04-2099'
let str2 = '2024-04'

const reg = /(?<year>[0-9]{4})-[0-9]{2}|[0-9]{2}-(?<year>[0-9]{4})/

/// before
/// å› ä¸ºä½¿ç”¨äº†é‡å¤çš„ç»„å <year> å¯¼è‡´æŠ¥é”™
str1.match(reg) // Error 
str2.match(reg) // Error

/// now 
str1.match(reg).groups.year // 2099
str2.match(reg).groups.year // 2024
```
::


::accordion{title="Set æ–°å¢é€»è¾‘è¿ç®—æ–¹æ³•"}

- äº¤é›†: `Set<T>.intersection(set: Set<T>): Set<T>`
- å¹¶é›†: `Set<T>.union(set: Set<T>): Set<T>`
- å·®é›†/è¡¥é›†: `Set<T>.difference(set: Set<T>): Set<T>`
- å¯¹ç§°å·®: `Set<T>.symmetricDifference(set: Set<T>): Set<T>`
- å­é›†: `Set<T>.isSubsetOf(set: Set<T>): boolean`
- è¶…é›†: `Set<T>.isSupersetOf(set: Set<T>): boolean`
- äº’æ–¥: `Set<T>.isDisjointFrom(set: Set<T>): boolean`

``` ts
const a = new Set([1, 2, 3])
const b = new Set([4, 3, 2])

// äº¤é›† a * b
b.intersection(a) // b âˆ© a => Set{3, 2} 
a.intersection(b) // a âˆ© b => Set{2, 3}

// å¹¶é›† a + b
a.union(b)        // a âˆª b => Set{1, 2, 3, 4}
b.union(a)        // b âˆª a => Set{4, 3, 2, 1}

// å·®é›†ï¼ša - b
a.difference(b)   // a âˆ– b => Set{1}
b.difference(a)   // b âˆ– a => Set{4}

// å¯¹ç§°å·®ï¼šä¸¤ä¸ªé›†åˆä¸­ä¸é‡å¤çš„å…ƒç´ 
a.symmetricDifference(b) // a Î” b => Set{1, 4}
b.symmetricDifference(a) // b Î” a => Set{4, 1}

// æ˜¯å­é›†
a.isSubsetOf(b) // false
b.isSubsetOf(a) // false

const c = new Set([3, 2])

c.isSubsetOf(a) // true
c.isSubsetOf(b) // true


// æ˜¯è¶…é›†
a.isSupersetOf(c) // true
b.isSupersetOf(a) // false

// äº’æ–¥ï¼Œä¸¤ä¸ªé›†åˆæ²¡æœ‰å…±åŒå…ƒç´ 
a.isDisjointFrom(b) // false
c.isDisjointFrom(a) // false

const d = new Set([1, 4])
d.isDisjointFrom(c) // true
```



::


## ES2024

::accordion{title="æ ¼å¼æ­£ç¡®çš„ Unicode å­—ç¬¦ä¸²"}

ä¸º `String` æä¾›ä¸¤ä¸ªæ–¹æ³•ï¼Œæ ¡éªŒå­—ç¬¦ä¸²æ˜¯å¦æ ¼å¼æ­£ç¡® 

- `String.isWellFormed(): boolean`
- `String.toWellFormed(): string`

``` ts
if (!someString.isWellFormed()) { 
  someString = someString.toWellFormed()
}
```

**polyfill**

``` ts
!/\p{Surrogate}/u.test(str) // boolean
```

``` ts
function isWellFormed(str) {
  for (let i = 0; i < str.length; ++i) {
    const isSurrogate = (str.charCodeAt(i) & 0xF800) == 0xD800;
    if (!isSurrogate) {
      continue;
    }
    const isLeadingSurrogate = str.charCodeAt(i) < 0xDC00;
    if (!isLeadingSurrogate) {
      return false; // unpaired trailing surrogate
    }
    const isFollowedByTrailingSurrogate = i + 1 < str.length && (str.charCodeAt(i + 1) & 0xFC00) == 0xDC00;
    if (!isFollowedByTrailingSurrogate) {
      return false; // unpaired leading surrogate
    }
    ++i;
  }
  return true;
}
```

::

::accordion{title="`Atomics.waitAsync`"}

ç”¨äºåœ¨ JavaScript çš„å…±äº«å†…å­˜ (SharedArrayBuffer) ä¸­å¼‚æ­¥ç­‰å¾…åŸå­æ“ä½œçš„å®Œæˆã€‚è¿™ä¸ª API æ‰©å±•äº† Atomics.wait çš„èƒ½åŠ›ï¼Œä½¿å¾—åœ¨ç­‰å¾…æ—¶ä¸å†é˜»å¡ä¸»çº¿ç¨‹æˆ– Worker çº¿ç¨‹ï¼Œå› æ­¤æ›´åŠ é€‚ç”¨äºéœ€è¦å¼‚æ­¥å¤„ç†çš„åœºæ™¯ã€‚

æä¾›ä¸€ç§éé˜»å¡çš„æ–¹å¼ç­‰å¾…æ•°æ®å˜åŒ–ï¼Œåœ¨éœ€è¦è·¨çº¿ç¨‹é€šä¿¡çš„å¤æ‚åœºæ™¯ä¸­éå¸¸æœ‰ç”¨ã€‚


``` ts
// åˆ›å»ºå…±äº«ç¼“å†²åŒºå’Œè§†å›¾
const sharedBuffer = new SharedArrayBuffer(4); // 4 å­—èŠ‚çš„ç¼“å†²åŒº
const int32 = new Int32Array(sharedBuffer);

// åœ¨æŸä¸ªçº¿ç¨‹ä¸­å¼‚æ­¥ç­‰å¾…
Atomics.waitAsync(int32, 0, 0).value.then(result => {
    console.log("ç­‰å¾…ç»“æœ:", result); // å½“å€¼å‘ç”Ÿå˜åŒ–æ—¶ï¼Œè¿”å› "ok"
});

// åœ¨å¦ä¸€ä¸ªçº¿ç¨‹ä¸­æ”¹å˜å€¼
setTimeout(() => {
    Atomics.store(int32, 0, 1); // å°† int32[0] æ”¹å˜ä¸º 1
    Atomics.notify(int32, 0, 1); // é€šçŸ¥ç­‰å¾…çš„çº¿ç¨‹
}, 1000);
```

::

::accordion{title="RegExp v flag with set notation + properties of strings âŒ"}

``` ts
// æŸ¥æ‰¾é ASCII æ•°å­—ä»¥å°†å…¶è½¬æ¢ä¸º ASCII æ•°å­—çš„ä»£ç 

[\p{Decimal_Number}--[0-9]]

// æŸ¥æ‰¾ç‰¹å®šè„šæœ¬çš„ â€œword/identifier lettersâ€ èŒƒå›´

[\p{Script=Khmer}&&[\p{Letter}\p{Mark}\p{Number}]]

// å¯»æ‰¾ â€œbreaking spacesâ€

[\p{White_Space}--\p{Line_Break=Glue}]


```

::

::accordion{title="Resizable and growable ArrayBuffers"}

æ²¡æœ‰æŒ‡å®š `length` å¯ä»¥åŠ¨æ€ä¿®æ”¹ ArrayBuffer çš„é•¿åº¦ 

``` ts
let rab = new ArrayBuffer(1024, { maxByteLength: 1024 ** 2 });
// 0 offset, auto length
let U32a = new Uint32Array(rab);
assert(U32a.length === 256); // (1024 - 0) / 4
rab.resize(1024 * 2);
assert(U32a.length === 512); // (2048 - 0) / 4

// Non-0 offset, auto length
let U32b = new Uint32Array(rab, 256);
assert(U32b.length === 448); // (2048 - 256) / 4
rab.resize(1024);
assert(U32b.length === 192); // (1024 - 256) / 4

// Non-0 offset, fixed length
let U32c = new Uint32Array(rab, 128, 4);
assert(U32c.length === 4);
rab.resize(1024 * 2);
assert(U32c.length === 4);

// If a resize makes any accessible part of a TA OOB, the TA acts like
// it's been detached.
rab.resize(256);
assertThrows(() => U32b[0]);
assert(U32b.length === 0);
rab.resize(132);
// U32c can address rab[128] to rab[144]. Being partially OOB still makes
// it act like it's been detached.
assertThrows(() => U32c[0]);
assert(U32c.length === 0);
// Resizing the underlying buffer can bring a TA back into bounds.
// New memory is zeroed.
rab.resize(1024);
assert(U32b[0] === 0);
assert(U32b.length === 192);
```


::

::accordion{title="Array Grouping"}

ä¸€ä¸ªä½¿æ•°ç»„ï¼ˆå’Œå¯è¿­ä»£å¯¹è±¡ï¼‰ä¸­çš„é¡¹ç›®åˆ†ç»„æ›´å®¹æ˜“çš„ææ¡ˆã€‚

``` ts
const array = [1, 2, 3, 4, 5];

// `Object.groupBy` groups items by arbitrary key.
// In this case, we're grouping by even/odd keys
Object.groupBy(array, (num, index) => {
  return num % 2 === 0 ? 'even': 'odd';
});
// =>  { odd: [1, 3, 5], even: [2, 4] }

// `Map.groupBy` returns items in a Map, and is useful for grouping
// using an object key.
const odd  = { odd: true };
const even = { even: true };
Map.groupBy(array, (num, index) => {
  return num % 2 === 0 ? even: odd;
});
// =>  Map { {odd: true}: [1, 3, 5], {even: true}: [2, 4] }
```


::
::accordion{title="Promise.withResolvers"}

è¯¥æ–¹æ³•æä¾›ä¸€ä¸ªå®ä¾‹åŒ– `Promise` ä¹‹åé…ç½® `resolve` ä¸ `reject` è¡Œä¸º. æ„å‘³ç€å¯ä»¥å°‘å†™ä¸€å±‚åµŒå¥—, æˆ–è€…è®¾ç½®ä¸­é—´å˜é‡.

``` ts
// before
function request () {
  return new Promise((resolve, reject) => {
    asyncRequest(config, response => {
      const buffer = []
      response.on('data', data => buffer.push(data))
      response.on('end', () => resolve(buffer))
      response.on('error', reason => reject(reason))
    })
  })
}

// now
function request() {
  const { resolve, reject, promise } = Promise.withResolvers()

  asyncRequest(config, response => {
    const buffer = []
    response.on('data', data => buffer.push(data))
    response.on('end', () => resolve(buffer))
    response.on('error', reason => reject(reason))
  })

  return promise
}
```



``` ts
class Promise {
  static withResolvers() {
    let resolve
    let reject
    const promise = new Promise((res, rej) => {
      resolve = res
      reject = rej
    }) 

    return { resolve, reject, promise }
  }
}
```

::

::accordion{title="ArrayBuffer transfer âŒ"}

ArrayBufferå¯ä»¥é€šè¿‡ HTML çš„åºåˆ—åŒ–ç®—æ³•è¿›è¡Œä¼ è¾“å’Œåˆ†ç¦»ï¼Œä½†ç¼ºå°‘å…·æœ‰ç›¸åŒè¡¨ç°åŠ›çš„ç¼–ç¨‹ JS APIã€‚ç¼–ç¨‹ API å¯¹äºç¼–ç¨‹æ¨¡å¼å¾ˆæœ‰ç”¨ï¼Œä¾‹å¦‚è½¬ç§» ArrayBufferçš„æ‰€æœ‰æƒã€ä¼˜åŒ–çš„é‡æ–°åˆ†é…ï¼ˆå³é‡æ–°åˆ†é…è¯­ä¹‰ï¼‰ä»¥åŠå°†å¯è°ƒæ•´å¤§å°çš„ ArrayBuffer ä¿®å¤ä¸ºå›ºå®šé•¿åº¦çš„ ArrayBufferã€‚è¯¥ææ¡ˆé€šè¿‡å‘ ArrayBuffer.prototype æ·»åŠ æ–°æ–¹æ³•æ¥å¡«å……è¿™ç§è¡¨ç°å½¢å¼ã€‚


``` ts
class ArrayBuffer {
  // ... existing stuff

  // Returns a new ArrayBuffer with the same byte content
  // as this buffer for [0, min(this.byteLength, newByteLength)],
  // then detaches this buffer.
  //
  // The maximum byte length and thus the resizability of this buffer
  // is preserved in the new ArrayBuffer.
  //
  // Any new memory is zeroed.
  //
  // If newByteLength is undefined, it is set to this.bytelength.
  //
  // Designed to be implementable as a copy-free move or a realloc.
  //
  // Throws a RangeError unless all of the following are satisfied:
  // - 0 <= newByteLength
  // - If this buffer is resizable, newByteLength <= this.maxByteLength
  transfer(newByteLength);

  // Like transfer, except always returns a non-resizable ArrayBuffer.
  transferToFixedLength(newByteLength);

  // Returns whether this ArrayBuffer is detached.
  get detached();
}
```


::



## ES2023

::accordion{title="Change Array by Copy"}

ä¸ºæ•°ç»„æ–°å¢é¢å¤–çš„æ–¹æ³•ï¼Œè¿”å›æ•°ç»„çš„æ–°çš„å¤åˆ¶ã€‚ä¸ä¼šä¿®æ”¹åŸæ¥çš„æ•°ç»„

æ•°ç»„æ–°å¢æ–¹æ³•

- `Array<T>.toReversed(): Array<T>`
- `Array<T>.toSorted(compareFn): Array<T>`
- `Array<T>.toSpliced(start, deleteCount, ...items): Array<T>`
- `Array<T>.with(index, value): Array<T>`

ç±»å‹æ•°ç»„æ–°å¢æ–¹æ³•

- `TypedArray.prototype.toReversed(): TypedArray`
- `TypedArray.prototype.toSorted(compareFn): TypedArray`
- `TypedArray.prototype.with(index, value): TypedArray`

::

::accordion{title="Symbols as WeakMap keys"}

symbols ç±»å‹å¯ä»¥ä½œä¸º WeakMap çš„é”®

``` ts
const weak = new WeakMap();

// Pun not intended: being a symbol makes it become a more symbolic key
const key = Symbol('my ref');
const someObject = { /* data data data */ };

weak.set(key, someObject);
```

::

::accordion{title="Array find from last"}

æ•°ç»„æ·»åŠ äº†ä¸¤ä¸ªä»å°¾éƒ¨ç´¢å¼•çš„æ–¹æ³•

- `Array.prototype.findLast`
- `Array.prototype.findLastIndex`

``` ts
const foo = [{ value: 1 }, { value: 2 }, { value: 3}, { value: 2 }]

foo.findIndex((item) => item.value === 2) // 1
foo.findLastIndex((item) => item.value === 2) // 3

```

::


::accordion{title="Hashbang Grammar"}


æ”¯æŒå‘½ä»¤è¡Œæ–‡ä»¶ SheBang/Hashbang è¯­æ³•

``` ts
#!/usr/bin/env node
// in the Script Goal
'use strict';
console.log(1);
```

``` ts
#!/usr/bin/env node
// in the Module Goal
export {};
console.log(1);
```

::

---

## ES2022


::accordion{title="Class Fields"}

è®¾ç½®ç§æœ‰å±æ€§çš„æ–¹å¼æ˜¯åœ¨å˜é‡å‰é¢åŠ ä¸€ä¸ªä¿®é¥°ç¬¦ #:

``` ts
class ClassWithPrivateProperty {
  #privateField; // ç§æœ‰å˜é‡
  static #PRIVATE_STATIC_FIELD; // é™æ€ç§æœ‰å˜é‡

  constructor() {
    this.#privateField = 42;
  }

  #privateMethod() { // ç§æœ‰æ–¹æ³•
    return 'hello world';
  }

  static #privateStaticMethod() { // é™æ€ç§æœ‰æ–¹æ³•
    return 'hello world';
  }
}
```

::


::accordion{title="RegExp Match Indices"}

æ­£åˆ™è¡¨è¾¾å¼æ–°å¢ `d` flag, åŒæ—¶å¢åŠ äº† `hasIndices` å±æ€§æ¥åˆ¤æ–­æ˜¯å¦ä½¿ç”¨äº† `d` flag

- `d` æ ‡å¿—è¡¨ç¤ºæ­£åˆ™è¡¨è¾¾å¼åŒ¹é…çš„ç»“æœåº”è¯¥åŒ…å«æ¯ä¸ªæ•è·ç»„å­å­—ç¬¦ä¸²å¼€å§‹å’Œç»“æŸçš„ç´¢å¼•ã€‚
- å®ƒä¸ä¼šä»¥ä»»ä½•æ–¹å¼æ”¹å˜æ­£åˆ™è¡¨è¾¾å¼çš„è§£é‡Šæˆ–åŒ¹é…è¡Œä¸ºï¼Œå®ƒåªåœ¨åŒ¹é…çš„ç»“æœä¸­æä¾›é¢å¤–çš„ä¿¡æ¯ã€‚
- `RegExp.prototype.hasIndices() => boolean`


- [RegExp.prototype.hasIndices](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/hasIndices)


``` ts
const str1 = 'foo bar foo'

const regex1 = /foo/gd


regex1.hasIndices // true
regex1.exec(str1).indices // [0, 3]
regex1.exec(str1).indices // [8, 11]
regex1.exec(str1).indices // Error

[...str1.matchAll(regex1)]
// [
//   ['foo', index: 0, input: 'foo bar foo', indices: [0, 3]]
//   ['foo', index: 8, input: 'foo bar foo', indices: [8, 11]]
// ]

const regex2 = /foo/
regex2.hasIndices // false
regex2.exec(str1).indices // undefined
```

::


::accordion{title="Top Level `await`"}

æ”¯æŒåœ¨é¡¶å±‚(æ²¡æœ‰å‰ç½® `async`)ä½¿ç”¨ `await`

``` ts
let jQuery;
try {
  jQuery = await import('https://cdn-a.com/jQuery');
} catch {
  jQuery = await import('https://cdn-b.com/jQuery');
}
```

::

::accordion{title="Ergonomic brand checks for Private Fields"}


æ”¯æŒäº†ä½¿ç”¨ in å»åˆ¤æ–­ç§æœ‰å±æ€§åœ¨å¯¹è±¡é‡Œé¢å­˜ä¸å­˜åœ¨ã€‚

``` ts
class C {
  #brand;

  #method() {}

  get #getter() {}

  static isC(obj) {
    return #brand in obj && #method in obj && #getter in obj;
  }
}
```

::


::accordion{title="Array.prototype.at"}

ä¸ºæ•°ç»„æ·»åŠ ç”¨ç´¢å¼•è¯»å–å…ƒç´ çš„æ–¹æ³•ï¼Œæ”¯æŒè´Ÿæ•°ç´¢å¼•

- `Array<T>.prototype.at(index: number) => T`

``` ts
const a = [1, 2, 3]
a.at(1) // 1
a.at(-1) // 3
```

::


::accordion{title="Accessible Object.prototype.hasOwnProperty"}


Object æ–°å¢é™æ€æ–¹æ³•æ¥ç®€åŒ– `hasOwnProperty` çš„ä½¿ç”¨

``` ts
Object.hasOwn(obj, 'foo')
// ç›¸å½“äº
Object.prototype.hasOwnProperty.call(obj, 'foo')
```

obj å¦‚æœæ˜¯æ²¡æœ‰åŸå‹çš„å¯¹è±¡ï¼Œç›´æ¥è°ƒç”¨ hasOwnProperty ä¼šæŠ¥é”™

::


::accordion{title="Class Static Block"}


ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ç±»å†…éƒ¨å¼€è¾Ÿä¸€ä¸ªä¸“é—¨ä¸ºé™æ€æˆå‘˜åˆå§‹åŒ–çš„ä½œç”¨åŸŸ

``` ts
class Translator {
  static translations = {
    yes: 'ja',
    no: 'nein',
    maybe: 'vielleicht',
  };
  static englishWords = [];
  static germanWords = [];
  static _ = initializeTranslator(); // (A)
}
function initializeTranslator() {
  for (const [english, german] of Object.entries(Translator.translations)) {
    Translator.englishWords.push(english);
    Translator.germanWords.push(german);
  }
}

class Translator {
  static translations = {
    yes: 'ja',
    no: 'nein',
    maybe: 'vielleicht',
  };
  static englishWords = [];
  static germanWords = [];
  static { // (A)
    for (const [english, german] of Object.entries(this.translations)) {
      this.englishWords.push(english);
      this.germanWords.push(german);
    }
  }
}

```

::

::accordion{title="Error Cause"}

  Error ç±»ç¬¬äºŒä¸ªå‚æ•°ï¼Œæ–°å¢ä¸€ä¸ª `cause` å­—æ®µç”¨æ¥ä¼ å…¥è‡ªå®šä¹‰ä¿¡æ¯ã€‚

  ``` ts
  try {
    throw new RangeError('error-message', { cause: { foo: 'bar' } })
  }
  catch(e) {
    console.log(e.cause) // {foo: 'bar'} 
    console.log(e.message) // 'error-message' 
    console.log(e.name) // 'RangeError'
  }
  ```

::

---

## ES2021

::accordion{title="String.prototype.replaceAll"}

ä¸ºå­—ç¬¦ä¸²æ·»åŠ ä¸€ä¸ªå¯ä»¥å…¨å±€æ›¿æ¢ç‰¹å®šå­—ç¬¦ä¸²çš„æ–¹æ³•

- `String.prototype.replaceAll(searchValue: string, replaceValue: string) => string`
- `String.prototype.replaceAll(searchValue: string, replacer: Replacer) => string`
  - `Replacer: (s: string, i: number, raw: string) => string`

``` ts
const queryString = 'q=query+string+parameters'
const withSpaces = queryString.replace(/+/g, ' ')
const withSpaces = queryString.replaceAll('+', ' ')

'vbcv'.replaceAll('v', (s, i, raw) => {
  // 'v', 0, vbcv
  // 'v', 3, vbcv
  return 'a'
})
// 'abca'
```

::

::accordion{title="Promise.any"}


ä¸º Promise å¢åŠ äº†åœ¨ä»»æ„ä¸€ä¸ª promise è¾¾åˆ° `fulfilled` ä¹‹åè§¦å‘çš„é™æ€å‡½æ•°

- `Promise.any(promises: Promise[]) => Promise`

``` ts
const successPromise = new Promise(resolve => setTimeout(resolve, 3000))
const success2Promise = new Promise(resolve => setTimeout(resolve, 2500))
const errorPromise = new Promise((_, reject) => setTimeout(reject, 1000))

Promise.any([successPromise, success2Promise, errorPromise])
.then((success2PromiseResponse) => {
    // after 2.5s
    console.log(Date.now() - t, success2PromiseResponse)
})

Promise.race([successPromise, success2Promise, errorPromise])
.catch((errorPromiseResponse) => {
    // after 1s
})
```

``` ts
const errorPromise = new Promise((_, reject) => setTimeout(reject, 1000))
const error2Promise = new Promise((_, reject) => setTimeout(reject, 1500))

Promise.any([error2Promise, errorPromise])
.catch(e => {
    // after 1.5
    e // AggregateError: All promises were rejected
})
```

::



::accordion{title="WeakRefs"}


WeakRef å¯¹è±¡å…è®¸æ‚¨ä¿ç•™å¯¹å¦ä¸€ä¸ªå¯¹è±¡çš„å¼±å¼•ç”¨ï¼Œè€Œä¸ä¼šé˜»æ­¢è¢«å¼±å¼•ç”¨å¯¹è±¡è¢« GC å›æ”¶

[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakRef)

::

::accordion{title="Logical Assignment Operators"}


ä¸ºé€»è¾‘è¯­å¥æ·»åŠ ç®€å†™è¯­æ³•

``` ts
x &&= y  // ç›¸å½“äº x && (x = y)

x ||= y  // ç›¸å½“äº x || (x = y)

x ??= y  // ç›¸å½“äº x ?? (x = y)
```

::

::accordion{title="Numeric separators"}

æ•°å­—é—´å¯ä»¥æ·»åŠ åˆ†éš”ï¼Œæ–¹ä¾¿é˜…è¯»

``` ts
const a = 10_000 // 10000
const b = 1_0000_0000 // 100000000
```

::

---

## ES2020


::accordion{title="String.prototype.matchAll"}

ä¸ºå­—ç¬¦ä¸²ç±»å‹æ·»åŠ ä¸€ä¸ªæ ¹æ®æ­£åˆ™è¡¨è¾¾å¼è¿”å›å…¨éƒ¨åŒ¹é…ä¿¡æ¯çš„æ–¹æ³•

- `String.prototype.matchAll(regexp: RegExp) => Iterator`

è¿”å›ä¸€ä¸ªè¿­ä»£å™¨

``` ts
const str = 'abc_abc_abc'
str.match(/abc/)
// ['abc', index: 0, input: 'abc_abc_abc', groups: undefined]
str.match(/abc/g) 
// ['abc', 'abc', 'abc']

str.matchAll(/abc/)
// Error String.prototype.matchAll called with a non-global RegExp argument

str.matchAll(/abc/g)
// RegExpStringIteratorÂ {}

[...str.matchAll(/abc/g)]
// [
//     ['abc', index: 0, input: 'abc_abc_abc', groups: undefined],
//     ['abc', index: 4, input: 'abc_abc_abc', groups: undefined],
//     ['abc', index: 8, input: 'abc_abc_abc', groups: undefined]
// ] 

```

::


::accordion{title="import()"}


æ·»åŠ å…¨å±€å‡½æ•° `import`, ç”¨æ¥åŠ¨æ€å¼•å…¥ JavaScript

``` ts
// foo.js
export function foo {
    return 'foo'
}

import('./foo.js').then(module => {
    module.foo() // 'foo'
})
```

::



::accordion{title="BigInt"}


ç”¨æ¥è¡¨ç¤ºè¿‡å¤§çš„æ•´æ•°ã€‚å®ƒä¸èƒ½å’Œæ™®é€šNumberè¿›è¡Œæ··åˆè¿ç®—

[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt)

``` ts
big1 = 1n
num1 = 1
big1 === num1 // false
big1 == num1 // true ä¸æ™®é€šæ•°å­—ä¸ä¸¥æ ¼ç›¸ç­‰

const previousMaxSafe = BigInt(Number.MAX_SAFE_INTEGER);
const maxPlusOne = previousMaxSafe + 1n;
```

::


::accordion{title="Promise.allSettled"}

ä¸º Promise æ·»åŠ ä¸€ä¸ªåœ¨æ‰€æœ‰promiseéƒ½å¤„ç†å®Œåè§¦å‘çš„å‡½æ•° 

`Promise.allSettled<T>(promises: Promise<T>[]) => Promise<T[]>`

``` ts
const successPromise = new Promise(resolve => setTimeout(resolve, 3000))
const errorPromise = new Promise((_, reject) => setTimeout(reject, 1000))

Promise.all([successPromise, errorPromise])
.catch(() => {
    // after 1s
})

const errorPromise = new Promise((_, reject) => setTimeout(reject, 1000))
Promise.allSettled([errorPromise, errorPromise])
.then(res => {
    console.log(res)
})

Promise.allSettled([successPromise, errorPromise])
.then((res) => {
    // after 3s
    res
    // [
    //     {status: 'fulfilled', value: undefined}
    //     {status: 'rejected', reason: undefined}
    // ]
})
```

::



::accordion{title="globalThis"}


åœ¨å„ç§ç¯å¢ƒä¸­ç»Ÿä¸€å…¨å±€æ ‡é‡çš„åç§°

``` ts
globalThis === window || globalThis === global || globalThis === self
```

::


::accordion{title="for-in mechanics"}


ç»Ÿä¸€ for-in æšä¸¾é¡ºåº

::


::accordion{title="Optional Chaining(?.)"}


æ·»åŠ å¯é€‰çš„é“¾å¼è¯­æ³•è°ƒç”¨ã€‚æ˜¯ä¸€ç§çŸ­è·¯è¯­æ³•

``` ts
const foo = myForm.querySelector('input[name=foo]')?.value
```

::


::accordion{title="Nullish coalescing Operator(??)"}


ä¸ºæœªå®šä¹‰çš„å€¼(`null`, `undefined`)è®¾ç½®é»˜è®¤å€¼

``` ts
null ?? 'hi' // 'hi'
undefined ?? 'hi' // 'hi'
0 ?? 'hi' // 0
'' ?? 'hi' // ''
false ?? 'hi' // false
NaN ?? 'hi' // NaN
```

::


::accordion{title="import.meta"}


æš´éœ²å½“å‰JavaScriptæ¨¡å—ä¸Šä¸‹æ–‡çš„å…ƒæ•°æ®å±æ€§çš„å¯¹è±¡

``` ts
// main.mjs
import './foo.mjs?a=5&b=12'

// foo.mjs
new URL(import.meta.url).searchParams.get('a') // '5'
```

::


---

## ES2019

::accordion{title="Optional `catch` binding"}

å¯é€‰æ‹©æ˜¯å¦ä½¿ç”¨ catch çš„å‚æ•°

``` ts
// before
try {

} catch (e) {

}

// now
try {

} catch {

}

```

::


::accordion{title="JSON superset"}

å°†JavaScript çš„è¯­æ³•æ‹“å±•ä¸º JSON çš„è¶…é›†

ä¹‹å‰å¦‚æœJSONå­—ç¬¦ä¸²ä¸­åŒ…å«æœ‰è¡Œåˆ†éš”ç¬¦(\u2028) å’Œæ®µè½åˆ†éš”ç¬¦(\u2029)ï¼Œé‚£ä¹ˆåœ¨è§£æè¿‡ç¨‹ä¸­ä¼šæŠ¥é”™ã€‚

``` ts
// before
JSON.parse('"\u2028"');  // SyntaxError

// now
JSON.parse('"\u2028"');  // ''
``` 

::

::accordion{title="Symbol.prototype.description"}

`symbol` ç±»å‹å¢åŠ  `description` å±æ€§

``` ts
const s = Symbol('foo')
s.description // 'foo'
const s1 = Symbol()
s1.description // undefined
```

:: 

::accordion{title="Function.prototype.toString revision"}

ç»Ÿä¸€æ ‡å‡†ï¼Œè¦æ±‚è¿”å›å‡½æ•°çš„æºä»£ç 

``` ts
function foo() {
    console.log('hi')
}

foo.toString() // "function foo() {\n    console.log('hi')\n}"
```

:: 

::accordion{title="Object.fromEntries"}

`Object` æ–°å¢ä¸€ä¸ªé™æ€æ–¹æ³•

- `Object.fromEntries(entries: any[][]) => any` é€šè¿‡é”®å€¼å¯¹æ•°ç»„åˆ›å»ºå¯¹è±¡

``` ts
Object.fromEntries([[1, 2], [3, 4]]) // {1: 2, 3: 4}
Object.entries({1: 2, 3: 4}) // [['1', 2], ['3', 4]]
```


:: 

::accordion{title="Well-formed JSON.stringify"}

é˜²æ­¢JSON.stringifyè¿”å›æ ¼å¼é”™è¯¯çš„Unicodeå­—ç¬¦ä¸², ä¿è¯å¤šä¸ª unicode ç»„åˆèƒ½å¤Ÿæ­£ç¡®è½¬ä¹‰

``` ts
// before
JSON.stringify('\uD83D');  // '"ï¿½"'


// Non-BMP characters still serialize to surrogate pairs.
JSON.stringify('ğŒ†')
// â†’ '"ğŒ†"'
JSON.stringify('\uD834\uDF06')
// â†’ '"ğŒ†"'

// Unpaired surrogate code units will serialize to escape sequences.
JSON.stringify('\uDF06\uD834')
// â†’ '"\\udf06\\ud834"'
JSON.stringify('\uDEAD')
// â†’ '"\\udead"'
``` 


:: 

::accordion{title="String.prototype.{trimStart,trimEnd}"}

å­—ç¬¦ä¸²ç±»å‹å¢åŠ äº†ä¸¤ä¸ªç”¨äºåˆ é™¤å­—ç¬¦ä¸²å‰åçš„ç©ºæ ¼ã€‚åŒ¹é… `padStart`, `padEnd` çš„åå­—ã€‚åŠŸèƒ½ä¸ `trimLeft`, `trimRight` ç›¸åŒ

- `String.prototype.trimStart() => string`
- `String.prototype.trimEnd() => string`

``` ts
const str = '    Hello World    '
str.trimStart() // "Hello World    "
str.trimEnd() // "    Hello World"
```


:: 

::accordion{title="Array.prototype.{flat, flatMap}"}

æ•°ç»„ç±»å‹æ–°å¢ä¸¤ä¸ªç”¨äºå±•å¹³æ•°ç»„çš„æ–¹æ³•

- `Array<T>.prototype.flat(depth?: number) => T[]`
- `Array<T>.prototype.flatMap<K>(callback: (o: T, i: number) => K , thisArg?: This) => T[]`

``` ts
[1, [2, [3, [4, 5]]]].flat() // [1, 2, [3, [4, 5]]]
[1, [2, [3, [4, 5]]]].flat(2) // [1, 2, 3, [4, 5]]
[1, [2, [3, [4, 5]]]].flat(Infinity) // [1, 2, 3, 4, 5]
```

``` ts
// flatMap æ•ˆç‡æ›´é«˜
[1, 2, 3, 4].flatMap(x => [x * 2]) // [2, 4, 6, 8]
// ç›¸å½“äº
[1, 2, 3, 4].map(x => [x * 2]).flat() // [2, 4, 6, 8]
```

:: 


--- 

## ES2018


::accordion{title="Lifting template literal restriction"}

å¢å¼ºå­—ç¬¦ä¸²çš„èƒ½åŠ›ï¼Œæä¾›äº†æ ‡ç­¾å‡½æ•°

- [å¸¦æ ‡ç­¾çš„æ¨¡æ¿å­—ç¬¦ä¸² MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals#%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2)

``` ts

function myTag(strings, personExp, ageExp) {
  let str0 = strings[0]; // "That "
  let str1 = strings[1]; // " is a "
  let str2 = strings[2]; // "."

  let ageStr;
  if (ageExp > 99){
    ageStr = 'centenarian';
  } else {
    ageStr = 'youngster';
  }

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

myTag`That ${ 'Mike' } is a ${ 28 }.`;

// 'That Mike is a youngster.'
```

:: 

::accordion{title="`s` (dotAll) flag for regular expressions"}

æ­£åˆ™æ–°å¢flag `s` å…è®¸ `.` åŒ¹é…å­—ç¬¦ä¸²ä¸­çš„æ¢è¡Œç¬¦ 

``` ts
/hello.world/.test('hello\nworld') // false
/hello.world/s.test('hello\nworld') // true
```

:: 

::accordion{title="RegExp named capture groups"}

æ­£åˆ™å¢åŠ å‘½åæ•è·ï¼Œæ•è·çš„ç»„å°†ä¼šæ”¾å…¥ `groups` çš„å¯¹åº”å­—æ®µä¸­

``` ts
const regDate = /(?<year>\d+)-(?<month>\d+)-(?<date>\d+)/
const match = regDate.exec('2018-04-30')
const { year, month, date } = match.groups


const regDate = /(\d+)-(\d+)-(\d+)/
const match = regDate.exec('2018-04-30')
const [ _, year, month, date ] = match
```

:: 

::accordion{title="Rest/Spread Properties "}

ä¸ºå¯¹è±¡å¢åŠ äº† `...` æ‹“å±•åŠŸèƒ½

``` ts
const { a, ...rest } = { a: 1, b: 2, c: 3 }
a // 1
rest // { b: 2, c: 3 }

function foo(obj) {
    return obj
}

foo({ a: 1, ...rest }) // {a: 1, b: 2, c: 3 }
```







:: 

::accordion{title="RegExp Lookbehind Assertions"}

ä¸ºæ­£åˆ™å¢åŠ åå‘æ–­è¨€åŠŸèƒ½

``` ts
// å…ˆè¡Œæ–­è¨€(lookahead)
const reLookahead = /\D(?=[0-9\.]+)/
const match = reLookahead.exec('$123.89')
match[0] // '$'

// åå‘æ–­è¨€(lookbehind) 
// è‚¯å®šå½¢å¼(?<=)
const reLookbehind = /(?<=\D)[0-9\.]+/
const match = reLookbehind.exec('$123.89')
match[0] // 123.89
// å¦å®šå½¢å¼(?<!)
const reLookbehind = /(?<!\D)[0-9\.]+/
const match = reLookbehind.exec('$123.89')
match[0] // 23.89
```

:: 

::accordion{title="RegExp Unicode Property Escapes"}

æ­£åˆ™è¡¨è¾¾å¼ æ”¯æŒæ ¹æ® Unicode å±æ€§è¿›è¡ŒåŒ¹é…

- [Unicode property escapes MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions/Unicode_Property_Escapes)

`\p{UnicodePropertyName=UnicodePropertyValue}`

``` ts
const regexGreekSymbol = /\p{Script=Greek}/u;
regexGreekSymbol.test('Ï€');
// â†’ true

const sentence = 'A ticket to å¤§é˜ª costs Â¥2000 ğŸ‘Œ.';
sentence.match(/\p{Emoji_Presentation}/gu)
// ['ğŸ‘Œ']
```

:: 

::accordion{title="Promise.prototype.finally"}

ä¸º `Promise` ç±»å‹å¢åŠ  `finally` æ–¹æ³•ã€‚å®ƒå°†åœ¨ fulfilled æˆ– rejected æ‰§è¡Œ

``` ts
let loading = false

loading = true
fooPromise()
.then((response) => {
  // handle response
})
.catch((error) => {
  // handle error
})
.finally(() => {
  loading = false
})
```

:: 

::accordion{title="Asynchronous Iteration"}

await å¾ªç¯

- [`for await ... of` MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for-await...of)

``` ts
async function process(array) {
    for await (let i of array) {
        doSimething(i)
    }
}
```

:: 

---

## ES2017


::accordion{title="Object.values/Object.entries"}

`Object` æ–°å¢ä¸¤ä¸ªé™æ€æ–¹æ³•

- `Object.values(o: any) => any[]` è¿”å›å¯æšä¸¾å¯¹è±¡çš„å€¼çš„æ•°ç»„
- `Object.entries(o: any) => any[][]` è¿”å›å¯æšä¸¾å¯¹è±¡é”®å€¼å¯¹ï¼ˆ`[key,value]`ï¼‰çš„æ•°ç»„

``` ts
const foo = { x: 5, y: 12 }

Object.keys(foo) // ['x', 'y']

Object.values(foo) // [5, 12]
Object.entries(foo) // [['x', 5], ['y', 12]]
```

:: 

::accordion{title="String padding"}

å­—ç¬¦ä¸²ç±»å‹å¢åŠ äº†ä¸¤ä¸ªç”¨äºå¡«å……å­—ç¬¦ä¸²çš„æ–¹æ³•ã€‚ä¸€ä¸ªåœ¨å‰é¢å¡«å……ï¼Œä¸€ä¸ªåœ¨åé¢å¡«å……

- `string.padStart(maxLength: number, fillString?: string): string`
- `string.padEnd(maxLength: number, fillString?: string): string`

``` ts
'foo'.padStart(4)           // ' foo'
'foo'.padStart(7, 'hello ') // 'hellfoo'
'4'.padStart(3, '0')        // '004'

'foo'.padEnd(4)       // 'foo '
'foo'.padEnd(4, '12') // 'foo1'
```

:: 

::accordion{title="Object.getOwnPropertyDescriptors"}

ç”¨æ¥è·å–ä¸€ä¸ªå¯¹è±¡çš„æ‰€æœ‰è‡ªèº«å±æ€§çš„æè¿°ç¬¦ã€‚

- `Object.getOwnPropertyDescriptor(obj: any, prop: string): Descriptor`
- `Object.getOwnPropertyDescriptors(obj: any): { [key: keyof typeof obj]: Descriptor }`

``` ts
const foo = { x: 5, y: 12 }
Object.getOwnPropertyDescriptors(foo, 'x')
// {value: 5, writable: true, enumerable: true, configurable: true}

Object.getOwnPropertyDescriptors(foo, 'z')
// undefined

Object.getOwnPropertyDescriptors(foo)
/**
 {
  "x": {value: 5, writable: true, enumerable: true, configurable: true}
  "y": {value: 12, writable: true, enumerable: true, configurable: true}
 }
 */
```


:: 

::accordion{title="Trailing commas in function parameter lists and calls"}

å‡½æ•°çš„å‚æ•°æ”¯æŒå°¾é€—å·, ä¸ä¼šå½±å“ `function.length`

``` ts
function clownPuppiesEverywhere(
  param1,
  param2, // Next parameter that's added only has to add a new line, not modify this line
) { /* ... */ }

clownPuppiesEverywhere(
  'foo',
  'bar', // Next parameter that's added only has to add a new line, not modify this line
);
```

:: 

::accordion{title="Async functions"}

è¯­è¨€å±‚é¢å®ç° `async` ä¸ `await`

``` ts
function foo() {
  return Promise.resolve('bar')
}

(async function loaded() {
  try {
    await foo() // 'bar'
  }
  catch (e) {
    
  }
})()
```

:: 

::accordion{title="Shared memory and atomics"}

- [Atomics MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics)

SharedArrayBuffer å¯¹è±¡ç”¨æ¥è¡¨ç¤ºä¸€ä¸ªé€šç”¨çš„ï¼Œå›ºå®šé•¿åº¦çš„åŸå§‹äºŒè¿›åˆ¶æ•°æ®ç¼“å†²åŒºï¼Œç±»ä¼¼äº ArrayBuffer å¯¹è±¡ã€‚å¯¹è±¡ï¼Œä½†å®ƒä»¬å¯ä»¥ç”¨æ¥åœ¨å…±äº«å†…å­˜ä¸Šåˆ›å»ºè§†å›¾ã€‚ä¸ ArrayBuffer ä¸åŒçš„æ˜¯ï¼ŒSharedArrayBuffer ä¸èƒ½è¢«åˆ†ç¦»ã€‚

ä¸€ä¸ªæ–°çš„ä½çº§åˆ«Atomicså‘½åç©ºé—´å¯¹è±¡å’Œä¸€ä¸ªSharedArrayBufferæ„é€ å‡½æ•°ï¼Œæ¥ä½œä¸ºæ›´é«˜çº§åˆ«å¹¶å‘æŠ½è±¡çš„åŸå§‹æ„å»ºå—ã€‚å…±äº«å¤šä¸ªservice workerå’Œæ ¸å¿ƒçº¿ç¨‹ä¹‹é—´çš„SharedArrayBufferå¯¹è±¡çš„æ•°æ®ã€‚åœ¨workerä¹‹é—´å…±äº«æ•°æ®ï¼Œæ”¹å–„workerä¹‹é—´çš„åè°ƒã€‚

``` ts
new SharedArrayBuffer(length)
```

- [MDN Atomics](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics)


:: 

--- 

## ES2016


::accordion{title="æ•°ç»„æ·»åŠ  includes æ–¹æ³• Array.prototype.includes"}

- `Array<T>.includes(searchElement: T, fromIndex?: number): boolean`
- `TypedArray<T>.includes(searchElement: T, fromIndex?: number): boolean`

``` ts
[1, 2, 3].includes(2) // true
[1, 2, 3].includes(4) // false

[1, 2, NaN].includes(NaN) // true
[1, 2, NaN].indexOf(NaN) // -1

'abc'.includes('b') // true
'abc'.includes('b', 2) // false
```


Note:

- `indexOf` ä½¿ç”¨çš„æ˜¯ä¸¥æ ¼ç›¸ç­‰ï¼Œ`includes` ä½¿ç”¨çš„æ˜¯ `SameValueZero` æ¯”è¾ƒç®—æ³•ã€‚å‰è€…çš„æ„æ€è¯¥å…ƒç´ åœ¨æ•°ç»„ä¸­ç¬¬ä¸€æ¬¡å‡ºç°çš„ç´¢å¼•æ˜¯ä»€ä¹ˆï¼Œåè€…å¼ºè°ƒæ•°ç»„æ˜¯å¦åŒ…å«æŸä¸ªå…ƒç´ 
- [`TypedArray`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) ä¹Ÿæ·»åŠ äº†åŒæ ·çš„æ–¹æ³•

::

::accordion{title="æ•°å­—ç±»å‹æ”¯æŒä¹˜æ–¹æ“ä½œç¬¦ Exponentiation operator"}


``` ts
// x ** y

let squared = 2 ** 2 // same as: 2 * 2, Math.pow(2, 3)

let cubed = 2 ** 3 // same as: 2 * 2 * 2, Math.pow(2, 3)


// x **= y

let a = 2
a **= 2 // same as: a = a * a;

let b = 3
b **= 3 // same as: b = b * b * b;
```